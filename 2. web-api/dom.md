dom : document object model (문서 객체 모델)
파싱 : (문서에서) 원하는 데이터를 추출하는 것.
html 속 태그들 하나하나가 객체라고 보면 됨.

===============================================
태그, 클래스 이름을 통한 요소 노드 취득 방법은 추천하지 않는 방법!
why??
예를들어 li가.. 한 페이지에 수도 없이 들어가게 될텐데.. 그것들 중에 또 집어서 작업하기가 불편..
!! 단체로 잡아야할 필요가 있을 때도 있지만, 그 때에도 이 방법은 쓰지 않기.

===================================================
nums.__proto__ 사용할 수 있는 함수 목록을 보여줌.

==================================================

# querySelector(하나만 가져올 때) / querySelectorAll (여러개를 가져올 때)
## 중요하다기보다 이게 만능! css 선택자를 활용할 수 있음. #(id), .(class) 등등

===================================================
# querySelector에 맞는 문법이기는 하나 정보가 없다면 null이라고 뜨면 css 문법이 아니라면 오류가 나옴.

=================================================

노드리스트 = 유사 배열 타입

querySelectorAll = 여러개를 가져오면서 노드리스트 타입이 됨.

quiz에서 다른버전 방식보다 노말버전 방식이 반복문을 적게 돌리기 때문에 성능상 더 좋다.

변경할 속성값을 줄 때는 항상 문자열 안에 가둔다.
ex: 'italic', 'red', '1.5em' 등등

=====================
5/3일 화요일 DOM제어,조작
하나를 찾았으면 그 주변 애들을 가져올 수 있다.

# 중간 팁 script 태그는 아래에만 써야하냐? : 그렇다.  why? 문서들을 불러오고 나서 요소들을 뽑아내야지, 뭐가 만들어지기도 전에 뽑아내려고 하면 어캄

================================================
childNodes를 쓰면 좀 별로!!! 이유는...
예시
childNodes: NodeList(7)
0: text  === li 태그 옆에 들여쓰기 되어 생긴 공백이 0번 index가 됨. 
1: li.apple
2: text
3: li.banana
4: text
5: li.grape
6: text
length: 7

# 그러니까!!! 자식들을 보고 싶으면 .children을 써라.
# firstchild랑 lastchild는 childNodes를 기반으로 첫째, 마지막을 찾기 때문에 쓰지 마라!!!!
# 그럼 뭘 씀?? firstElementChild, lastElementChild를 써라. 그래야 children에서 첫째, 마지막을 제대로 뽑은거처럼 나온다.

==================================================
# 자식 태그를 확인하는 방법
hasChildNodes, isEmpty 등 동사가 먼저 나온다면 값을 논리형으로 리턴한다. 왜?? are you~~ , do you~~ 처럼 값이 있냐 없냐의 의문문 형태라서 ㅇㅇ

# hasChildNodes는 텍스트노드(공백마저도) 자식이라고 보기 때문에 사용하지 않는게 좋다.

# 중요) (!!children.length)는 텍스트노드를 제외하고 자식 요소가 있는지를 확인한다.

core-js. 5강 논리타입으로 변환 참고!!

=====================================================
# 부모, 형제 노드탐색.
(next, previous)ElementSibling;

=============================================
# 요소 탐색시 주의사항(table 태그)
## - table 태그의 자식태그는 무조건 자동으로! 입력하지 않아도! tbody가 생성되므로 주의할 것!!항상 tbody가 있다고 의식하고 요소 찾기 돌입해야함.
## tbody 밑에 tr, td가 생성됨.

=============================================

# 요소노드의 텍스트 조작.
## textcontent : 공백이 들어옴. 여기선 공백이 있어도 이걸 써라.(trim()이란 함수를 붙여주면 innertxet와 같이 공백을 없애주기 때문에 이걸 써라.)

==================================
# innerHTML의 타입은 string이다.
innerHTML은 <>을 인식해서 태그로 처리해준다.

but, 실수의 여지가 많다.

## innerHTML은 직속 자식요소를 전부 바꿔버리는듯! (그렇기에 변경을 하고 싶은게 있다면 바로 위에 부모를 기준점으로 잡아서 사용하자.)
## ex: 바로 윗부모.innerHTML = '';

==============================
# 화면에 이미 그려진 애들은 live_DOM, 가상에 존재하는 애들은 virtual_DOM.

# 메모리 관리 차원에서 가상끼리의 처리를 먼저 할 수 있다면 그게 가장 좋다!!

중간삽입은 insertBefore((가상이면 삽입, 이미 실존하는 애면 이동), (누구 앞에 놓을건지))!!

================================
# appendChild(), creatElement(), removeChild() 활용!!!

# ~~~Child의 공통점 : 부모를 기준으로 하는거임!!!

## appendChild : 배열에서의 .push처럼 알아서 맨 뒤에다가 붙임.

## creatElement : 기존에 없던 요소를 만든다.
활용 예시 : creatChild('li');
해석 : li태그를 새로 만들겠다!
## 보통 document 어딘가에 가상으로 만들어서 나중에 원하는 위치(insertBefor를 활용!)에 삽입한다.

## removeChild : 자식을 삭제하라. 기준으로 삼은 부모의 하위 자식들을 전부 다 삭제시킬거면 while(자식이 없을 때까지!: 지우다보면 논리값이 false가 되도록 작성)

=================================================

5월 4일 수요일 ~~~

# HTMLCollection 문제
## 발생하는 이유 : 유사배열이면서, 실시간으로 상태가 변동되는 DOM 객체라서.

# 유사배열에서 반복문을 돌리면 HTMLCollection 문제가 발생해서 원하는 결과를 제대로 얻기가 힘듦.

# 유사배열을 찐배열로 바꿔서 처리하면 문제 없다.

=================================================

이전까진 요소(태그)들을 통째로 취득해왔음.
그 속에서 있는 디테일(개별 속성들)을 취득하고 싶을 땐 아래의 방법들을 활용!!

attribute : 속성

# .getAttribute('');
# setAttribute('바꾸고자하는 속성', '바꿀 속성 값')

# 없는 속성을 추가하고자 할 때도 setAttribute 활용!!
## setAttribute ('원래 존재하지 않던 속성이면서 내가 새로 만들고자 하는 속성', '해당 속성의 값')

# removeAttribute('지울 속성값');
만약!!!) data-~~~ 속성이라면 이 방법이 아니라 delete로 지워야함. 객체 프로퍼티 지우듯이

# hasAttribute('확인하고자 하는 속성값');
## 있다, 없다의 논리형으로 리턴이 됨. 제어, 반복문에서의 조건식으로 활용 가능!

========================================

# 중요!!!)) data 속성(attribute) 제어

## 이 data- 속성이 있으면 굳이 서버와 통신을 하지 않고도 html과 js간의 빠른 통신이 가능함.

# 예시) 김철수 li 태그에 data-user-address 속성 추가. how?? 아예 없는 속성을 동적 추가.

## $li1.dataset.userAddress = '서울시 중구'; // 이러면 html body 태그에는 케밥 케이스(user-address)로 추가된다. 신기한데??

## 삭제할 때는 delete 사용!!

==========================================

# 스타일 조작 (css 조작)

# 하위 함수는 클래스만 조작 가능!!!

# replace(교체할 대상, 뭐라고 교체할건데?); 교체할 때
# add(추가), remove(제거), contains(담고있냐? 아니냐?), toggle(있으면 넣고, 없으면 제거해라)


==========================================
==========================================

# 이벤트!!
이벤트 타입 : (마우스, 키보드, 값변경, 기타 이벤트등이 있음.)

## 이벤트 기초!
====================
## 어트리뷰트 방식(이벤트를 속성값처럼 쓰자.)
## [on + 이벤트타입="이벤트 발생시 호출할 함수"] ==>> ))이건 html 태그 안에 속성으로 넣는거라고 함.

브라우저야!! 이벤트가 발생했을 때 내가 알려준 함수를 호출하렴.

### 알아두라는 뜻에서 알려줬지만 인라인 스타일 태그 같은 것이기 때문에 안쓰는 것이 좋다. 좋은건 아닌데.. 음.. 잘 모르겠네?? 일단 알아두자.

==================

# 이벤트 - 프로퍼티 방식

## 모든 요소에는 기본적으로 on~~~에 관련된 기본값이 null로 부여되어있다. 이걸 응용해서 다이렉트로 스크립트 태그 속에서 $~~.on~~~ = [이벤트 발생시 표현하고자 하는 것.]; 이라고 표현할 수 있다!!

그러나,,,,,,

## 이후 같은 $~~.on~~~에 다른!! [이벤트 발생시 표현하고자 하는 것.]을 넣을 경우 기존에 설정한 것이 사라짐. why?? 객체에서 어떤 key의 값을 변경할 때랑 똑같이 하다보니 생기는 현상.

## quiz02번을 풀어보니까.. 한 함수 안에 2가지 동작을 입력하려 했더니 안되네??? 별로인듯.

==================

# 이벤트 - addEventListener 방식
## 이건 뒤에 추가가 됨.
## addEventListener('이벤트 발생 조건(클릭, 더블클릭 등)', 발생시 뭐가 발생되게 할건데??(주로 함수로 넣는다.));

====================================================================================

2022.05.09

# 복습

setAttribute를 통해 img 태그의 src속성값을 변경해서 이미지를 변경할 수도 있다.

setAttribute를 했다가 기존에 있던 속성값이 수정되는 것을 막기 위해 기존에 있었는지 없었는지를 확인하기 위해 hasAttribute를 먼저 확인함.

프로그래밍 팁!
없는데 뭐 하라고 하면 에러나기 쉬우니 먼저 만약에 있으면 지워! 라고 hasAtt로 확인 후, removeAtt를 활용.

# $box.style.fontSize = '1.2em'; // 이러면 프로퍼티에 style 속 값으로 반영이 됨.
그러나 css에서 만지면 개발자도구 탭의 style 부분에는 반영이 안됨.

만약에 함수들이 잘 이해가 안된다면
js classList method 이런식으로 구글에 검색해서 공식홈에서 사용법을 확인해볼 것.

====================

# 프로퍼티 방식과 add이벤트리스너에서 주의!!

# $b1.onclick = sayHello;는 함수 자체를 대입하겠다는 뜻!

# $b1.onclick = sayHello(); 라고 한다면 sayHello라는 함수의 리턴값을 대입하겠다는 뜻.

# 이 차이를 매우 주의!!!

=====================

# 프로퍼티 방식에서 sayHello같이 그냥 함수만 쓰는 경우는 그 함수를 나중에도 또 쓰고자 할 때!
## 그런 경우가 아니라면 일회성인 즉시 실행 함수를 활용.

=====================
05.09
# 진도

# 키보드 이벤트 부분 재밌네. function(e) 활용!
# 잘 모르겠으면 console.log(e) 찍어가면서 찾자.

# 교안 4페이지 부분 
## type : keyup(내가 키보드를 입력했으니까)
## target : 이벤트가 어느 요소(태그)에서 일어났는지 알려줌.
## curruntTarget : 이건 왜 null??

# curruntTarget은 이벤트를 걸어준 태그!!
# target과 curruntTarget은 다를 수 있음!(target이 curruntTarget에 종속되어 있는 경우 즉, 자식인 경우.)

=======================

# 이벤트 전파!!! 매우중요))

자기한테 이벤트가 걸린게 아닌데 부모한테 있나? 를 확인해보려고 보글보글 올라가는게 버블링 효과다. 그래서 부모에게 이벤트가 있으면 나도 그 이벤트를 가져와서 수행하게 됨.

그러면,,

부모 때문에 자식 중 일부에겐 걸고 일부에게는 안걸고 싶었던 이벤트가 걸릴 수가 있음.

# stopPropagation() : 이 함수가 들어간 위치에서 멈추고 그 위로 올라가는 버블링을 하지 말아라.

# 성능 측면에서 일부러 버블링을 시키는 경우도 있다!!!

=======================

# event.preventDefault() : 요소의 기본 동작을 중단시킨다.

## 이게 무슨 말이냐? p태그는 별 기능이 없지만 a태그는 기능이 있듯이.

# form은 html에서 구조적인 의미로다가 서버로 데이터를 넘겨주기 위해 마련한 박스! 그 박스 속에 input, button 등 서버로 보낼 것들을 담아서 보낸다. (링크를 쓰고자 할 때, 국룰처럼 a 태그를 쓰는 것과 같은 맥락이다.)

=======================
이벤트 위임1

중요))
# e.target.matches('#fruits > li') : 현재 이벤트를 실행한 곳의 위치가 ('')에 포함된다면 true! 아니라면 false가 도출된다.

)) 깨알!!
input으로 입력을 받을 때 그 값은 input 프로퍼티에서 value: '여기!'에 저장된다!!!

toLowerCase() : 다 소문자로 받을 때 쓴다.

====================
7. 이벤트위임2에서!!

))
# input이랑 button을 form으로 감싸면 input에서 엔터쳤을 때 알아서 버튼이 작동하도록 연동된다. (form 자체에서의 기능)

약어로 래핑
내 vs 코드에선 [컨트롤 + 쉬프트 + p]