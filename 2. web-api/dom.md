dom : document object model (문서 객체 모델)
파싱 : (문서에서) 원하는 데이터를 추출하는 것.
html 속 태그들 하나하나가 객체라고 보면 됨.

===============================================
태그, 클래스 이름을 통한 요소 노드 취득 방법은 추천하지 않는 방법!
why??
예를들어 li가.. 한 페이지에 수도 없이 들어가게 될텐데.. 그것들 중에 또 집어서 작업하기가 불편..
!! 단체로 잡아야할 필요가 있을 때도 있지만, 그 때에도 이 방법은 쓰지 않기.

===================================================
nums.__proto__ 사용할 수 있는 함수 목록을 보여줌.

==================================================

# querySelector(하나만 가져올 때) / querySelectorAll (여러개를 가져올 때)
## 중요하다기보다 이게 만능! css 선택자를 활용할 수 있음. #(id), .(class) 등등

===================================================
# querySelector에 맞는 문법이기는 하나 정보가 없다면 null이라고 뜨면 css 문법이 아니라면 오류가 나옴.

=================================================

노드리스트 = 유사 배열 타입

querySelectorAll = 여러개를 가져오면서 노드리스트 타입이 됨.

quiz에서 다른버전 방식보다 노말버전 방식이 반복문을 적게 돌리기 때문에 성능상 더 좋다.

변경할 속성값을 줄 때는 항상 문자열 안에 가둔다.
ex: 'italic', 'red', '1.5em' 등등

=====================
5/3일 화요일 DOM제어,조작
하나를 찾았으면 그 주변 애들을 가져올 수 있다.

# 중간 팁 script 태그는 아래에만 써야하냐? : 그렇다.  why? 문서들을 불러오고 나서 요소들을 뽑아내야지, 뭐가 만들어지기도 전에 뽑아내려고 하면 어캄

================================================
childNodes를 쓰면 좀 별로!!! 이유는...
예시
childNodes: NodeList(7)
0: text  === li 태그 옆에 들여쓰기 되어 생긴 공백이 0번 index가 됨. 
1: li.apple
2: text
3: li.banana
4: text
5: li.grape
6: text
length: 7

# 그러니까!!! 자식들을 보고 싶으면 .children을 써라.
# firstchild랑 lastchild는 childNodes를 기반으로 첫째, 마지막을 찾기 때문에 쓰지 마라!!!!
# 그럼 뭘 씀?? firstElementChild, lastElementChild를 써라. 그래야 children에서 첫째, 마지막을 제대로 뽑은거처럼 나온다.

==================================================
# 자식 태그를 확인하는 방법
hasChildNodes, isEmpty 등 동사가 먼저 나온다면 값을 논리형으로 리턴한다. 왜?? are you~~ , do you~~ 처럼 값이 있냐 없냐의 의문문 형태라서 ㅇㅇ

# hasChildNodes는 텍스트노드(공백마저도) 자식이라고 보기 때문에 사용하지 않는게 좋다.

# 중요) (!!children.length)는 텍스트노드를 제외하고 자식 요소가 있는지를 확인한다.

core-js. 5강 논리타입으로 변환 참고!!

=====================================================
# 부모, 형제 노드탐색.
(next, previous)ElementSibling;

=============================================
# 요소 탐색시 주의사항(table 태그)
## - table 태그의 자식태그는 무조건 자동으로! 입력하지 않아도! tbody가 생성되므로 주의할 것!!항상 tbody가 있다고 의식하고 요소 찾기 돌입해야함.
## tbody 밑에 tr, td가 생성됨.

=============================================

# 요소노드의 텍스트 조작.
## textcontent : 공백이 들어옴. 여기선 공백이 있어도 이걸 써라.(trim()이란 함수를 붙여주면 innertxet와 같이 공백을 없애주기 때문에 이걸 써라.)

==================================
# innerHTML의 타입은 string이다.
innerHTML은 <>을 인식해서 태그로 처리해준다.

but, 실수의 여지가 많다.

## innerHTML은 직속 자식요소를 전부 바꿔버리는듯! (그렇기에 변경을 하고 싶은게 있다면 바로 위에 부모를 기준점으로 잡아서 사용하자.)
## ex: 바로 윗부모.innerHTML = '';

==============================
# 화면에 이미 그려진 애들은 live_DOM, 가상에 존재하는 애들은 virtual_DOM.

# 메모리 관리 차원에서 가상끼리의 처리를 먼저 할 수 있다면 그게 가장 좋다!!

중간삽입은 insertBefore((가상이면 삽입, 이미 실존하는 애면 이동), (누구 앞에 놓을건지))!!

================================
# appendChild(), creatElement(), removeChild() 활용!!!

# ~~~Child의 공통점 : 부모를 기준으로 하는거임!!!

## appendChild : 배열에서의 .push처럼 알아서 맨 뒤에다가 붙임.

## creatElement : 기존에 없던 요소를 만든다.
활용 예시 : creatChild('li');
해석 : li태그를 새로 만들겠다!
## 보통 document 어딘가에 가상으로 만들어서 나중에 원하는 위치(insertBefor를 활용!)에 삽입한다.

## removeChild : 자식을 삭제하라. 기준으로 삼은 부모의 하위 자식들을 전부 다 삭제시킬거면 while(자식이 없을 때까지!: 지우다보면 논리값이 false가 되도록 작성)

===================================